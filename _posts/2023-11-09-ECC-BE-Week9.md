---
title: SQL 레벨업 1-2장
author: Su
date: 2023-11-09 01:55:00 +0800
categories: [CS]
tags: [ECC, BE]
pin: false
use_math: true

---

Learning Source: [SQL 레벨업 - 미크](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=75566292)
<BR>

2장은 SQL 첫걸음에서 다룬 SQL 기초이기 때문에 따로 정리하지 않았다.
<BR><BR>

# **1장 DBMS 아키텍처**
## **1. DBMS 아키텍처 개요**
<img src="https://github.com/sml09181/sml09181.github.io/assets/105408672/5221cb4b-58dc-4d85-8d99-2193222a20f6" width="550">

+ 데이터베이스 사용자(일반 사용자 또는 프로그래머)와의 인터페이스로부터 전달된 SQL 구문은 중간에 있는 DBMS를 통해 다양한 처리를 수행한다.
+ 이후 저장 장치의 데이터에 접근하여 데이터를 읽고 쓰게 된다.

### DBMS 내부 기능
+ <code>쿼리 평가 엔진🚩</code>: 사용자로부터 입력받은 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지 결정
  + `Explain Plan`(실행 계획): 이때 결정되는 계획
  + `Access Method`(접근 메서드): 이러한 Explain Plan에 기반을 둬서 데이터에 접근하는 방법
+ <code>버퍼 매니저</code>: 버퍼 영역 관리
  + `버퍼`: DBMS가 확보하는 특별한 용도의 메모리 영역
  + 디스크 용량 매니저와 함께 연동되어 작동
+ <code>디스크 용량 매니저</code>: 어디에 어떻게 데이터를 저장할지를 관리하고, 데이터의 read, write를 제어한다.
  + DB는 웹 서버나 애플리케이션 서버와 달리 데이터를 영구적으로 저장해야 한다.
+ <code>트랜잭션 매니저</code>와 <code>락 매니저</code>
  + 상용 시스템에서는 다수의 사람이 동시에 데이터베이스에 접근하여 사용
  + 이때 각각의 처리는 DBMS 내부에서 `트랜잭션`이라는 단위로 관리된다.
  + 트랜잭션 매니저와 락 매니저는 이러한 트랜잭션의 정합성을 유지하면서 실행시키고, 필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시킨다.
+ <code>리커버리 매니저</code>: 시스템 장애에 대비하여 데이터를 정기적으로 백업하고, 문제가 일어났을 때 복구 작업을 수행한다.<BR><BR>
+ 이 책에서는 하나의 SQL 구문을 독립적으로 실행할 때의 성능을 중심으로 설명하기 때문에, 동시에 실행할 때 발생하는 충돌과 같은 관점은 살펴보지 않는다. 

## **2. DBMS와 버퍼**
+ 데이터를 버퍼에 확보하는 방식에 trade-off 발생<br>
<img src="https://github.com/sml09181/sml09181.github.io/assets/105408672/5d2dce6d-44b8-406b-9b29-2ccf1f31c1f1" width="550">

+ <code>기억 비용</code>: 데이터를 저장하는 데 소모되는 비용
+ 위 그림에서 면적이 큰 것은 같으 비용으로 저장할 수 있는 데이터 용량이 많다는 것을 나타낸다.
+ 많은 데이터의 영속적 저장-속도의 trade-off 발생

### DBMS와 기억장치의 관계
+ <code>Hard Disk(HDD)</code>, Solid State Drive(SSD): 2차 기억장치
  + 데이터는 대부분 이곳에 저장된다.
+ <code>Memory</code>: 1차 기억 장치
  + 디스크에 비해 기억 비용이 굉장히 비싸다.
  + 하드디스크와 비교했을 때 매우 작은 크기
  + Buffer 또는 Cache(캐시): DBMS는 성능 향상을 위해 일부라도 데이터를 메모리에 올린다. 이때 사용하는 메모리.
    + 사용자와 저장소 사이에서 데이터 전송 지연을 완화시킴
    + 이 책에서는 버퍼와 캐시를 거의 같은 용어로 사용
    + 데이터를 어떻게, 어느 정도의 기간 동안 올릴까? ▶️ 버퍼 매니저
+ 일반적으로 SQL 구문의 실행 시간 대부분을 저장소 I/O(입출력)에 사용하고 있기 때문에, 디스크 접근을 줄일 수 있다면 굉장히 큰 폭의 성능 향상이 가능하다.<br>
<img src="https://github.com/sml09181/sml09181.github.io/assets/105408672/92efedad-b07f-412c-a7fb-f404b3e23319" width="500">

### 메모리 위에 있는 두 개의 버퍼
+ DBMS가 데이터를 유지하기 위해 사용하는 메모리: 데이터 캐시, 로그 버퍼<br>
<img src="https://github.com/sml09181/sml09181.github.io/assets/105408672/1118488d-1ce2-40ac-aa57-73461e79d497" width="500">

+ <code>데이터 캐시</code>: 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역
  + SELECT와 관련
+ <code>로그 버퍼</code>
  + 갱신 처리(INSERT, DELETE, UPDATE, MERGE)와 관련
  + DBMS가 갱신과 관련된 SQL을 받으면 곧바로 저장소에 있는 데이터를 변경하는 것이 아니라, 로그 버퍼 위에 변경 정보를 보내고 이후 디스크에 변경 작업을 수행한다.
  + 데이터베이스의 갱신 처리 ▶️ SQL 구문의 실행 시점과 저장소에 갱신하는 시점에 차이가 있는 비동기 처리<br>
    + 시점 차이를 두는 이유: 갱신을 할 때 상당한 시간이 소모되기 때문에, 저장소 변경이 끝날 때까지 기다리면 사용자는 장기간 대기하게 된다.
      + 한 번 메모리에 갱신 정보를 받은 시점에서 사용자에게 작업이 끝났다고 알린다. 
      + 내부적으로는 관련 처리 계속 수행<br>
    <img src="https://github.com/sml09181/sml09181.github.io/assets/105408672/1418670b-6a27-4c69-9b0c-bdedf5d8aae3" width="500">

### 메모리의 성질이 초래하는 Trade-off
+ 메모리 단점
  + 가격이 비싸서 보유할 수 있는 데이터 양이 적다.
  + 휘발성: 데이터의 영속성X
    + DBMS에 어떤 장애가 발생해서 프로세스 다운이 일어나면(=서버가 죽으면), 메모리에 있는 모든 데이터가 날아간다. ▶️ 데이터 부정합
    + 로그 파일에 전달된 갱신 정보가 DBMS가 다운될 때 사라지는 현상 해결법: 커밋 시점에 반드시 갱신 정보를 영속적인 저장소 위에 있는 로그 파일에 쓴다. ▶️ Trade-off 재발생
      + Commit: 갱신 처리를 '확정'한다.
      + DBMS는 커밋된 데이터를 영속화한다.
  + 디스크에 동기 처리: 데이터 정합성⬆️, 성능⬇️
  + 디스크에 비동기 처리: 데이터 정합성⬇️, 성능⬆️

### 시스템 특성에 따른 Trade-off
+ 데이터 캐시에 비해 로그 버퍼의 초깃값은 굉장히 작다 ▶️ 비대칭적인 크기
  + 이유: DB가 기본적으로 검색을 메인으로 처리한다고 가정하기 때문
  + 검색 처리를 할 때는 검색 대상 레코드가 수백만에서 수천만 건에 달하는 경우도 많다.
  + 하지만 갱신 처리의 대상은 많아 봤자 트랜잭션마다 한 건에서 수만 건 정도밖에 안 된다.
+ 갱신 처리에 값비싼 메모리를 많이 사용하는 것보다는, 자주 검색하는 데이터를 캐시에 올려 놓는 게 더 낫다.
+ 튜닝(최적화) 등을 통해 로그 버퍼의 크기를 늘려 줄 수 있다.
+ 최근의 DBMS는 리소스와 메모리 할당을 자동으로 조정할 수 있다.<br>
<img src="https://github.com/sml09181/sml09181.github.io/assets/105408672/495a42b6-f0ec-435e-8d8f-41076c80c5d2" width="450">

+ 정리
  + 로그 버퍼 크기 큼: 갱신 처리와 관련해 큰 부하가 걸릴 것을 고려한 설계
  + 데이터 캐시 크기 큼: 검색 처리와 관련된 처리가 중심(or 기본 설정 사용)

### 추가적인 메모리 영역 '워킹 메모리'
+ DBMS는 앞의 데이터 캐시와 로그 버퍼 말고도 일반적으로 메모리 영역을 하나 더 가지고 있다.
+ <code>Working Memory</code>(워킹 메모리): 정렬 또는 해시 관련 처리에 사용되는 작업용 영역
  + 정렬: ORDER BY 구, 집합 연산, 윈도우 함수 등의 기능을 사용할 때 실행된다.
  + 해시: 주로 테이블 등의 결합에서 해시 결합이 사용되는 때(+GROUP BY) 실행된다.
  + SQL에서 정렬 또는 해시가 필요할 때 사용되고, 종료되면 해제되는 임시 영역
  + 만약 Working Memory가 부족해지면 대부분의 DBMS가 저장소를 사용한다(OS 동작에서의 Swap)<br>
  <img src="https://github.com/sml09181/sml09181.github.io/assets/105408672/18ee0f36-0766-43ed-8dd2-052b4cb90338" width="500">
  + 이름과 관리 방법은 DBMS에 따라 다르다.
+ 각 DBMS에서 Working Memory를 부르는 명칭
  + Oracle 11g R2: PGC(Program Global Area)
  + PostgreSQL 9.3: 워크 버퍼
  + MySQL 5.7: 정렬 버퍼
+ 각 DBMS에서 Working Memory가 부족할 때 사용하는 임시 영역(접근 속도 느리다)
  + Oracle: TEMP Tablespace(임시 테이블 스페이스)
  + Microsoft SQL Server: TEMPDB
  + PostgreSQL: pgsql_tmp(일시 영역)
+ 메모리에서 작동하고 잇을 때는 빠르게 움직이다가 메모리가 부족해지는 순간 갑자기 느려지는 순간적인 변화가 문제이다.
+ 여러 개의 SQL 구문을 동시에 실행할 때 부하 검사를 실시하지 않으면 메모리 부족 현상 발생 유무를 판별하기 힘들다.
+ DB는 메모리가 부족하다는 이유로 SQL 구문에 오류를 절대 발생시키지 않는다.

## **3. DBMS와 실행 계획**
+ 비절차적 RDB: 데이터에 접근하기 위한 절차(How)를 시스템에게 맡기고 사용자는 오직 대상(What)을 기술한다. ▶️ 비즈니스 전체의 생산성 향상
+ 데이터 접근 방법: 결정 by 쿼리 평가 모듈(여러 개의 서브 모듈로 구성됨)
+ 데이터 접근 서브 모듈
  +  1️⃣ <code>Parser</code>(파서): 구문 분석(Parse)
     +  사용자가 작성하는 SQL 구문은 항상 구문적으로 올바르다는 보증이 없다. ▶️ 검사
     +  SQL 구문은 정형적인 형석으로 변환 ▶️ DBMS 내부에서의 후속 처리 효율화
  +  <code>Optimizer</code>: 데이터 접근법(실행 계획) 최적화
     + 2️⃣ 많은 선택 가능한 실행 계획 작성
       + 인덱스 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등의 조건 고려
     + 3️⃣ 위 계획들의 비용 연산 ▶️ 이후 가장 낮은 비용을 가진 계획 선택
  +  4️⃣ <code>Catalog Manager</code>(카탈로그 매니저): Optimizer가 실행 계획을 세울 때 중요한 정보(카탈로그 정보) 제공
     +  `Catalog`: DBMS의 내부 정보를 모아 놓은 테이블들
        +  테이블 또는 인덱스의 통계 정보가 저장되어 있음
  + 5️⃣ Plan Evaluation: Optimizer가 세운 SQL 구문에서 여러 개의 실행 계획을 받아 최적의 실행 결과를 산텍
    + 실행 계획은 오히려 인간이 읽기 쉽게 만들어졌다.
    + 하나의 실행 계획을 선택하면, 이후 DBMS는 실행 계획을 절차적인 코드로 변환하고 데이터 접근을 수행한다.<br>
<img src="https://github.com/sml09181/sml09181.github.io/assets/105408672/c1b22852-2ca4-4e85-a876-f8067dd82af7" width="550">


### 옵티마이저와 통계 정보(카탈로그 정보를 일컫음)

+ Catalog에 포함되어 있는 통계 정보들
  + 각 table의 record 수
  + 각 table의 field 수와 field의 크기
  + field의 cardinality(값의 개수)
  + field값의 히스토그램(어떤 값이 얼마나 분포되어 있는가)
  + field 내부에 있는 NULL값 수
  + index 정보
+ Optimizer가 최적의 플랜을 선택하지 못하는 대표적 이유: 통계 정보가 부족한 경우
  + Catalog 정보가 table 또는 index의 실제와 일치하지 않을 때 문제 발생
  + table에 데이터 삽입/갱신/제거가 수행될 때 catalog 정보도 반드시 갱신해야 한다. ▶️ 갱신 시점을 확실하게 검토해야 함
  + Garbage In, Garbage Out


## **4. 실행 계획이 SQL 구문의 성능을 결정**

SQL 구문의 지연이 발생했을 때 제일 먼저 실행 계획을 살펴 봐야 한다.

### 실행 계획 확인 방법
+ 모든 DBMS는 실행 계획을 조사하는 수단을 제공한다. 명령행 인터페이스에서 확인할 수 있다. <br>
<img src="https://github.com/sml09181/sml09181.github.io/assets/105408672/5e035130-b65b-4e32-bcc2-4533001d2092">

+ 3가지 기본적인 SQL 실행계획
  + 1️⃣ 테이블 풀 스캔(Full Scan)의 실행 계획
  + 2️⃣ 인덱스 스캔의 실행 계획
  + 3️⃣ 간단한 테이블 결합의 실행 계획
+ sample table<br>
<img src="https://github.com/sml09181/sml09181.github.io/assets/105408672/191feb9c-9d4c-4627-8b3b-93cfe0aa9918" width="400">


### 1️⃣ 테이블 풀 스캔(Full Scan)의 실행 계획
```sql
SELECT * FROM Shops;

--PostgreSQL--
EXPLAIN

--Oracle--
set autotrace traceronly
```
+ 공통적인 결과
  + 조작 대상 객체 ▶️ Shops
    + 객체: table, index, 파티션, 시퀀스 등(SQL 구문으로 조작할 수 있는 것이라면 무엇이든)
  + 🌟 객체에 대한 조작의 종류
    + PostgreSQL
      + 문장의 앞 부분
      + `Seq Scan`(Sequential Scan): 파일을 순차적으로 접근해서 해당 테이블의 데이터 전체를 읽어낸다 
      + 조금 더 물리저거 차원에 가까운 출력
    + Oracle
      + `Operation` field
      + `TABLE ACCESS FULL`: 테이블의 데이터를 전부 읽어들인다. 
  + 조작 대상이 되는 레코드 수 ▶️ Rows
    + 1개의 SQL 구문을 실행해도 결합 또는 집약이 포함되면 여러 개의 조작이 수행된다. ▶️ 각 조작에서 얼마만큼의 레코드가 처리되는지가 SQL 구문 전체의 실행 비용을 파악하는 데 중요한 지표가 된다.
    + Optimizer가 실행 계획을 만들 때, catalog manager로부터 얻은 값, 즉 통계 정보에서 파악한 값이다.

### 2️⃣ 인덱스 스캔의 실행 계획

```sql
SELECT *
  FROM Shops
  WHERE shop_id = '00050';
```

+ 조작 대상이 되는 레코드 수 ▶️ 기본키이므로 1
+ 접근 대상 객체와 조작
  + <code>B-tree</code>: 모집합의 데이터양에 따라 대수 함수적으로 처리 비용이 늘어난다.
    + 인덱스 처리 비용이 완만하게 증가한다.
    + 데이터양이 충분히 크면, 인덱스 스캔이 풀 스캔보다도 효율적인 접근을 한다.<br>
  <img src="https://github.com/sml09181/sml09181.github.io/assets/105408672/dba3f767-1cef-48c5-81fa-3785a3f85c1d" width="400">

### 3️⃣ 간단한 테이블 결합의 실행 계획
+ 결합을 수행하려면 테이블이 두 개 이상 필요하므로 새로운 sample table 추가<br>
<img src="https://github.com/sml09181/sml09181.github.io/assets/105408672/347c00ef-1433-410b-80e2-5f4ac7e119fd">
  
+ 예약이 존재하는 점포를 선택하는 SELECT 구문
```sql
SELECT shop_name
  FROM Shops S INNER JOIN Rservations R
  ON S.shop_id = R.shop_id;
```
+ DBMS가 결합을 할 때 사용하는 3가지 알고리즘
  + <code>Nested Loops</code>: 한쪽 테이블을 읽으면서 레코드 하나마다 결합 조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식
    + 절차 지향형 언어로 구현하면, 이중 반복으로 구현됨
    + PostgreSQL, Oracle에서 모두 사용
  + <code>Sorted Merge</code>: 결합 키로 레코드를 정렬하고, 순차적으로 두 개의 테이블을 결합하는 방법
    + 원칙적으로 결합 전 전처리(정렬)을 해야 함
    + 이때 작업용 메모리로 워킹 메모리 사용
  + <code>Hash</code>: 결합 키값을 해시값으로 맵핑
    + 해시 테이블을 만들어야 하므로, 작업용 메모리 영역을 필요로 한다.

## 5. 실행 계획의 중요성
사실 사용자가 실행 계획을 읽는다는 것은 데이터베이스의 이상을 어기는 일이지만, 세상 모든 것이 이상적으로 돌아가지는 않는다.

 